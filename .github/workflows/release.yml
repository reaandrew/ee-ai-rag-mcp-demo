name: Release and Deploy

on:
  workflow_run:
    workflows: ["Main Branch Quality Gate"]
    branches: [main]
    types:
      - completed

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write  # Needed for AWS auth

jobs:
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "lts/*"

      - name: Install dependencies
        run: npm install

      - name: Semantic Release
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use semantic-release directly and save the exit code
          npx semantic-release || echo "Semantic release process completed"
          
          # Check if a new tag was created by looking at git tags
          git fetch --tags
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [[ ! -z "$LATEST_TAG" ]]; then
            echo "new_release_published=true" >> $GITHUB_OUTPUT
            # Remove v prefix if present
            VERSION=${LATEST_TAG#v}
            echo "new_release_version=$VERSION" >> $GITHUB_OUTPUT
            echo "A new release was published: $VERSION"
          else
            echo "new_release_published=false" >> $GITHUB_OUTPUT
            echo "No new release was published"
          fi

  terraform:
    name: Terraform Deploy
    needs: release
    runs-on: ubuntu-latest
    if: ${{ needs.release.outputs.new_release_published == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ee-ai-rag-mcp-demo-ci-role
          role-session-name: GitHub_AWS_Terraform
          aws-region: eu-west-2
          
      - name: Install Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.5.7"
          
      - name: Build Lambda Packages
        run: |
          # Install pip dependencies
          python -m pip install --upgrade pip
          
          # Ensure build scripts are executable
          chmod +x ./install_lambda_deps.sh
          chmod +x ./build_lambda.sh
          
          # Build the Lambda layers - using simplified approach with minimal dependencies
          ./install_lambda_deps.sh
          
          # Build Lambda packages with utility modules
          ./build_lambda.sh
          
          # Verify the packages were created
          ls -la build/
          
          # Show the sizes of key packages
          du -h build/text-chunker-layer.zip
          du -h build/policy-search.zip
          du -h build/vector-generator.zip
          
      # Set environment variables for Terraform backend and variables
      - name: Set Terraform Environment Variables
        env:
          RELEASE_VERSION: ${{ needs.release.outputs.new_release_version }}
        run: |
          # Backend configuration
          echo "TF_STATE_BUCKET=ee-ai-rag-mcp-demo-terraform-state" >> $GITHUB_ENV
          echo "TF_LOCK_TABLE=ee-ai-rag-mcp-demo-terraform-locks" >> $GITHUB_ENV
          
          # Terraform variables
          echo "TF_VAR_environment=prod" >> $GITHUB_ENV
          echo "TF_VAR_app_version=${RELEASE_VERSION}" >> $GITHUB_ENV
          echo "TF_VAR_raw_pdfs_bucket_name=ee-ai-rag-mcp-demo-raw-pdfs" >> $GITHUB_ENV  # Remove version from bucket name
          echo "TF_VAR_extracted_text_bucket_name=ee-ai-rag-mcp-demo-extracted-text" >> $GITHUB_ENV  # Add proper prefix
          echo "TF_VAR_extracted_text_prefix=ee-ai-rag-mcp-demo" >> $GITHUB_ENV
          
          # For debugging
          echo "Setting up Terraform for version: ${RELEASE_VERSION}"
          
      - name: Terraform Init
        working-directory: ./terraform/app
        run: terraform init -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" -backend-config="region=eu-west-2" -backend-config="dynamodb_table=${{ env.TF_LOCK_TABLE }}" -backend-config="key=terraform/app/terraform.tfstate"
        
      - name: Terraform Plan
        working-directory: ./terraform/app
        run: terraform plan -out=tfplan
        
      - name: Terraform Apply
        working-directory: ./terraform/app
        run: terraform apply -auto-approve tfplan
        
      - name: Ensure build directories exist
        run: |
          mkdir -p ${GITHUB_WORKSPACE}/build/bruno/RAG-Policy-Search
          
      - name: Display Terraform Outputs
        working-directory: ./terraform/app
        run: |
          echo "Terraform deployment completed successfully!"
          echo "Bucket Name: $(terraform output -raw raw_pdfs_bucket_name)"
          echo "Bucket ARN: $(terraform output -raw raw_pdfs_bucket_arn)"
          echo "Deployed Version: $(terraform output -raw deployed_version)"
          echo "API URL: $(terraform output -raw policy_search_api_url)"
          echo "API Script: $(terraform output -raw api_curl_script_path)"
          
          # Debug Bruno collection (only if it exists)
          if [ -f "$(terraform output -raw bruno_collection_path 2>/dev/null)" ]; then
            echo "Bruno collection URL inclusion check:"
            cat "$(terraform output -raw bruno_collection_path)" | grep -A 2 "API_URL" || echo "No API_URL found in Bruno collection"
          else
            echo "Bruno collection file not found - will be created during apply"
          fi
          
          # Verify Bruno README (only if it exists)
          if [ -f "${GITHUB_WORKSPACE}/build/bruno/README.md" ]; then
            echo "Bruno README API URL check:"
            cat "${GITHUB_WORKSPACE}/build/bruno/README.md" | grep -A 1 "API URL" || echo "No API URL found in README"
          else
            echo "Bruno README file not found - will be created during apply"
          fi
          
      - name: Check and Upload API Query Script Artifact
        run: |
          if [ -f "build/query_api.sh" ]; then
            echo "API query script found, making it executable"
            chmod +x build/query_api.sh
          else
            echo "WARNING: API query script not found at build/query_api.sh"
            # Create a fallback script with the API URL as a backup
            mkdir -p build
            API_URL=$(cd terraform/app && terraform output -raw policy_search_api_url)
            
            # Create script with proper indentation in the heredoc
            cat > build/query_api.sh << EOF
#!/bin/bash
# Fallback query script created during CI process
# Original script not found, using extracted API URL

API_URL="$API_URL"
AUTH_TOKEN="YOUR_AUTH_TOKEN"  # Replace with actual token

# Function to make API call
query_api() {
  local query="\$1"
  
  # Create temporary file for request body
  TMPFILE=\$(mktemp)
  echo "{\\"query\\": \\"\$query\\"}" > \$TMPFILE
  
  # Make the API call
  curl -X POST \\
    -H "Content-Type: application/json" \\
    -H "Authorization: Bearer \$AUTH_TOKEN" \\
    --data @\$TMPFILE \\
    "\$API_URL"
    
  # Clean up temp file
  rm \$TMPFILE
}

# Check if query was provided as argument
if [ \$# -eq 0 ]; then
  echo "Usage: \$0 \\"your policy question here\\""
  echo "Example: \$0 \\"What is our password policy?\\""
  exit 1
fi

# Execute query
query_api "\$1"
EOF
            chmod +x build/query_api.sh
            echo "Created fallback query script with API URL: ${API_URL}"
          fi
      
      - name: Upload API Query Script Artifact
        uses: actions/upload-artifact@v4
        with:
          name: api-query-script
          path: build/query_api.sh
          retention-days: 30
          if-no-files-found: error
          
      - name: Prepare Bruno Collection Artifacts
        run: |
          if [ ! -d "build/bruno/RAG-Policy-Search" ]; then
            echo "Bruno collection directory not found, creating minimal structure"
            mkdir -p build/bruno/RAG-Policy-Search
            
            # Create minimal bruno.json if missing
            if [ ! -f "build/bruno/RAG-Policy-Search/bruno.json" ]; then
              API_URL=$(cd terraform/app && terraform output -raw policy_search_api_url)
              
              # Create Bruno JSON file with proper indentation
              cat > build/bruno/RAG-Policy-Search/bruno.json << EOF
{
  "version": "1",
  "name": "RAG-Policy-Search",
  "type": "collection",
  "schema": "https://schema.getbruno.io/collection/v1.json",
  "environment": {
    "value": "{{environments.default}}",
    "vars": {}
  },
  "environments": {
    "default": {
      "API_URL": "$API_URL", 
      "AUTH_TOKEN": "test-token"
    },
    "production": {
      "API_URL": "$API_URL",
      "AUTH_TOKEN": "YOUR_TOKEN_HERE"
    }
  }
}
EOF
              echo "Created minimal bruno.json with API URL: ${API_URL}"
            fi
            
            # Create minimal request file if missing
            if [ ! -f "build/bruno/RAG-Policy-Search/Search Policy.bru" ]; then
              
              # Create Bruno request file
              cat > "build/bruno/RAG-Policy-Search/Search Policy.bru" << 'EOF'
meta {
  name: Search Policy
  type: http
  seq: 1
}

post {
  url: {{API_URL}}
  body: json
  auth: none
}

headers {
  Content-Type: application/json
  Authorization: Bearer {{AUTH_TOKEN}}
}

body:json {
  {
    "query": "What is our password policy?"
  }
}

docs {
  # RAG Policy Search

  This request searches all indexed policy documents using natural language.
  
  The system will:
  1. Convert your query to vector embeddings
  2. Find the most relevant policy chunks in OpenSearch
  3. Use Claude 3 Sonnet to generate a comprehensive answer
  4. Return both the answer and source citations
}
EOF
              echo "Created minimal Search Policy.bru file"
            fi
            
            # Create README if missing
            if [ ! -f "build/bruno/README.md" ]; then
              API_URL=$(cd terraform/app && terraform output -raw policy_search_api_url)
              
              # Create README file
              cat > build/bruno/README.md << EOF
# RAG Policy Search API Bruno Collection

This Bruno collection is automatically generated by Terraform with the correct API URL for your deployment.

## API Details

- **API URL**: \`$API_URL\`
- **Content Type**: application/json
- **Authentication**: Bearer token (placeholder in collection)

## Usage Instructions

1. Open Bruno app
2. Import this collection folder
3. Select the environment (default or production)
4. Use the "Search Policy" request to query the RAG system

## Request Format

\`\`\`json
{
  "query": "What is our password policy?"
}
\`\`\`

## Response Format

\`\`\`json
{
  "query": "What is our password policy?",
  "answer": "Based on the policy excerpts...",
  "sources": [
    {
      "document_name": "Acceptable Encryption Policy",
      "page_number": 3
    }
  ]
}
\`\`\`

Generated during CI: $(date)
EOF
              echo "Created README.md with API URL: ${API_URL}"
            fi
          fi
          
      - name: Upload Bruno Collection Artifact
        uses: actions/upload-artifact@v4
        with:
          name: bruno-collection
          path: build/bruno/
          retention-days: 30
          if-no-files-found: error