name: Release and Deploy

on:
  workflow_run:
    workflows: ["Main Branch Quality Gate"]
    branches: [main]
    types:
      - completed

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write  # Needed for AWS auth

jobs:
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "lts/*"

      - name: Install dependencies
        run: npm install

      - name: Semantic Release
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use semantic-release directly and save the exit code
          npx semantic-release || echo "Semantic release process completed"
          
          # Check if a new tag was created by looking at git tags
          git fetch --tags
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [[ ! -z "$LATEST_TAG" ]]; then
            echo "new_release_published=true" >> $GITHUB_OUTPUT
            # Remove v prefix if present
            VERSION=${LATEST_TAG#v}
            echo "new_release_version=$VERSION" >> $GITHUB_OUTPUT
            echo "A new release was published: $VERSION"
          else
            echo "new_release_published=false" >> $GITHUB_OUTPUT
            echo "No new release was published"
          fi

  terraform:
    name: Terraform Deploy
    needs: release
    runs-on: ubuntu-latest
    if: ${{ needs.release.outputs.new_release_published == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ee-ai-rag-mcp-demo-ci-role
          role-session-name: GitHub_AWS_Terraform
          aws-region: eu-west-2
          
      - name: Install Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.5.7"
          
      - name: Build Lambda Packages
        run: |
          # Install pip dependencies
          python -m pip install --upgrade pip
          
          # Ensure build scripts are executable
          chmod +x ./install_lambda_deps.sh
          chmod +x ./build_lambda.sh
          
          # Build the Lambda layers - using simplified approach with minimal dependencies
          ./install_lambda_deps.sh
          
          # Build Lambda packages with utility modules
          ./build_lambda.sh
          
          # Verify the packages were created
          ls -la build/
          
          # Show the sizes of key packages
          du -h build/text-chunker-layer.zip
          du -h build/policy-search.zip
          du -h build/vector-generator.zip
          
      # Set environment variables for Terraform backend and variables
      - name: Set Terraform Environment Variables
        env:
          RELEASE_VERSION: ${{ needs.release.outputs.new_release_version }}
        run: |
          # Backend configuration
          echo "TF_STATE_BUCKET=ee-ai-rag-mcp-demo-terraform-state" >> $GITHUB_ENV
          echo "TF_LOCK_TABLE=ee-ai-rag-mcp-demo-terraform-locks" >> $GITHUB_ENV
          
          # Terraform variables
          echo "TF_VAR_environment=prod" >> $GITHUB_ENV
          echo "TF_VAR_app_version=${RELEASE_VERSION}" >> $GITHUB_ENV
          echo "TF_VAR_raw_pdfs_bucket_name=ee-ai-rag-mcp-demo-raw-pdfs" >> $GITHUB_ENV  # Remove version from bucket name
          echo "TF_VAR_extracted_text_bucket_name=ee-ai-rag-mcp-demo-extracted-text" >> $GITHUB_ENV  # Add proper prefix
          echo "TF_VAR_extracted_text_prefix=ee-ai-rag-mcp-demo" >> $GITHUB_ENV
          
          # For debugging
          echo "Setting up Terraform for version: ${RELEASE_VERSION}"
          

      - name: Terraform Init
        working-directory: ./terraform/app
        run: terraform init -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" -backend-config="region=eu-west-2" -backend-config="dynamodb_table=${{ env.TF_LOCK_TABLE }}" -backend-config="key=terraform/app/terraform.tfstate"
        
      - name: Terraform Plan
        working-directory: ./terraform/app
        run: terraform plan -out=tfplan
        
      - name: Terraform Apply
        working-directory: ./terraform/app
        run: terraform apply -auto-approve tfplan
        
      - name: Ensure build directories exist
        run: |
          mkdir -p ${GITHUB_WORKSPACE}/build/bruno/RAG-Policy-Search
          
      - name: Display Terraform Outputs
        working-directory: ./terraform/app
        run: |
          echo "Terraform deployment completed successfully!"
          echo "Bucket Name: $(terraform output -raw raw_pdfs_bucket_name)"
          echo "Bucket ARN: $(terraform output -raw raw_pdfs_bucket_arn)"
          echo "Deployed Version: $(terraform output -raw deployed_version)"
          echo "API URL: $(terraform output -raw policy_search_api_url)"
          echo "API Script: $(terraform output -raw api_curl_script_path)"
          
          # Debug Bruno collection (only if it exists)
          if [ -f "$(terraform output -raw bruno_collection_path 2>/dev/null)" ]; then
            echo "Bruno collection URL inclusion check:"
            cat "$(terraform output -raw bruno_collection_path)" | grep -A 2 "API_URL" || echo "No API_URL found in Bruno collection"
          else
            echo "Bruno collection file not found - will be created during apply"
          fi
          
          # Verify Bruno README (only if it exists)
          if [ -f "${GITHUB_WORKSPACE}/build/bruno/README.md" ]; then
            echo "Bruno README API URL check:"
            cat "${GITHUB_WORKSPACE}/build/bruno/README.md" | grep -A 1 "API URL" || echo "No API URL found in README"
          else
            echo "Bruno README file not found - will be created during apply"
          fi
          
      # Add a separate job for deploying UI files
  ui-deploy:
    name: Deploy UI Files
    needs: terraform
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ee-ai-rag-mcp-demo-ci-role
          role-session-name: GitHub_AWS_S3_UI_Deploy
          aws-region: eu-west-2
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.5.7"
      
      - name: Install Dependencies
        run: |
          # Install required system packages
          sudo apt-get update
          sudo apt-get install -y jq
          
          # Install Python dependencies
          python -m pip install --upgrade pip
          python -m pip install jinja2>=3.1.2 boto3>=1.28.0
          chmod +x ./scripts/render_template.py
      
      - name: Get Terraform Outputs
        working-directory: ./terraform/app
        run: |
          # Initialize Terraform to access remote state
          terraform init -backend-config="bucket=ee-ai-rag-mcp-demo-terraform-state" -backend-config="region=eu-west-2" -backend-config="dynamodb_table=ee-ai-rag-mcp-demo-terraform-locks" -backend-config="key=terraform/app/terraform.tfstate"
          
          # Save all outputs to a JSON file first
          terraform output -json > tf_outputs.json
          
          # Extract specific values using jq and set as environment variables
          UI_BUCKET=$(jq -r '.ui_bucket_name.value' tf_outputs.json)
          SEARCH_API_URL=$(jq -r '.policy_search_api_url.value' tf_outputs.json)
          STATUS_API_URL=$(jq -r '.document_status_api_url.value' tf_outputs.json)
          CLOUDFRONT_URL=$(jq -r '.cloudfront_url.value' tf_outputs.json)
          
          # Set as GitHub environment variables
          echo "UI_BUCKET=$UI_BUCKET" >> $GITHUB_ENV
          echo "SEARCH_API_URL=$SEARCH_API_URL" >> $GITHUB_ENV
          echo "STATUS_API_URL=$STATUS_API_URL" >> $GITHUB_ENV
          echo "CLOUDFRONT_URL=$CLOUDFRONT_URL" >> $GITHUB_ENV
          
          # Debug output
          echo "UI Bucket: $UI_BUCKET"
          echo "Search API URL: $SEARCH_API_URL"
          echo "Status API URL: $STATUS_API_URL"
          echo "CloudFront URL: $CLOUDFRONT_URL"
        
      - name: Process Templates and Upload UI Files
        run: |
          echo "UI Bucket: $UI_BUCKET"
          echo "Search API URL: $SEARCH_API_URL"
          echo "Status API URL: $STATUS_API_URL"
          echo "CloudFront URL: $CLOUDFRONT_URL"
          
          # Create build directory
          mkdir -p ./build/ui
          
          # Process index.html template
          ./scripts/render_template.py \
            --template ./ui/index.html \
            --output ./build/ui/index.html \
            --search-api "$SEARCH_API_URL" \
            --status-api "$STATUS_API_URL"
          
          # Upload index.html
          aws s3 cp ./build/ui/index.html "s3://$UI_BUCKET/index.html" --content-type "text/html"
          
          # Upload documentation.html
          aws s3 cp ./ui/documentation.html "s3://$UI_BUCKET/documentation.html" --content-type "text/html"
          
          # Upload all image files
          aws s3 cp ./ui/images/ "s3://$UI_BUCKET/images/" --recursive
          
          echo "UI files deployed successfully to $UI_BUCKET"
          echo "UI is accessible at: $CLOUDFRONT_URL"