name: Release and Deploy

on:
  workflow_run:
    workflows: ["Main Branch Quality Gate"]
    branches: [main]
    types:
      - completed

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write  # Needed for AWS auth

jobs:
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "lts/*"

      - name: Install dependencies
        run: npm install

      - name: Semantic Release
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Use semantic-release directly and save the exit code
          npx semantic-release || echo "Semantic release process completed"
          
          # Check if a new tag was created by looking at git tags
          git fetch --tags
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [[ ! -z "$LATEST_TAG" ]]; then
            echo "new_release_published=true" >> $GITHUB_OUTPUT
            # Remove v prefix if present
            VERSION=${LATEST_TAG#v}
            echo "new_release_version=$VERSION" >> $GITHUB_OUTPUT
            echo "A new release was published: $VERSION"
          else
            echo "new_release_published=false" >> $GITHUB_OUTPUT
            echo "No new release was published"
          fi

  terraform:
    name: Terraform Deploy
    needs: release
    runs-on: ubuntu-latest
    if: ${{ needs.release.outputs.new_release_published == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ee-ai-rag-mcp-demo-ci-role
          role-session-name: GitHub_AWS_Terraform
          aws-region: eu-west-2
          
      - name: Install Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.5.7"
          
      - name: Build Lambda Packages
        run: |
          # Install pip dependencies
          python -m pip install --upgrade pip
          
          # Ensure build scripts are executable
          chmod +x ./install_lambda_deps.sh
          chmod +x ./build_lambda.sh
          
          # Build the Lambda layers - using simplified approach with minimal dependencies
          ./install_lambda_deps.sh
          
          # Build Lambda packages with utility modules
          ./build_lambda.sh
          
          # Verify the packages were created
          ls -la build/
          
          # Show the sizes of key packages
          du -h build/text-chunker-layer.zip
          du -h build/policy-search.zip
          du -h build/vector-generator.zip
          
      # Set environment variables for Terraform backend and variables
      - name: Set Terraform Environment Variables
        env:
          RELEASE_VERSION: ${{ needs.release.outputs.new_release_version }}
        run: |
          # Backend configuration
          echo "TF_STATE_BUCKET=ee-ai-rag-mcp-demo-terraform-state" >> $GITHUB_ENV
          echo "TF_LOCK_TABLE=ee-ai-rag-mcp-demo-terraform-locks" >> $GITHUB_ENV
          
          # Terraform variables
          echo "TF_VAR_environment=prod" >> $GITHUB_ENV
          echo "TF_VAR_app_version=${RELEASE_VERSION}" >> $GITHUB_ENV
          echo "TF_VAR_raw_pdfs_bucket_name=ee-ai-rag-mcp-demo-raw-pdfs" >> $GITHUB_ENV  # Remove version from bucket name
          echo "TF_VAR_extracted_text_bucket_name=ee-ai-rag-mcp-demo-extracted-text" >> $GITHUB_ENV  # Add proper prefix
          echo "TF_VAR_extracted_text_prefix=ee-ai-rag-mcp-demo" >> $GITHUB_ENV
          
          # For debugging
          echo "Setting up Terraform for version: ${RELEASE_VERSION}"
          

      - name: Terraform Init
        working-directory: ./terraform/app
        run: terraform init -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" -backend-config="region=eu-west-2" -backend-config="dynamodb_table=${{ env.TF_LOCK_TABLE }}" -backend-config="key=terraform/app/terraform.tfstate"
        
      - name: Terraform Plan
        working-directory: ./terraform/app
        run: terraform plan -out=tfplan
        
      - name: Terraform Apply
        working-directory: ./terraform/app
        run: terraform apply -auto-approve tfplan
        
      - name: Ensure build directories exist
        run: |
          mkdir -p ${GITHUB_WORKSPACE}/build/bruno/RAG-Policy-Search
          
      - name: Install Jinja2 for UI templating
        run: |
          python -m pip install jinja2>=3.1.2
          chmod +x ./scripts/render_template.py
      
      - name: Read Terraform outputs
        id: tf
        working-directory: ./terraform/app
        run: |
          echo "Terraform deployment completed successfully!"
          
          # Grab each value into a shell variable
          UI_BUCKET=$(terraform output -raw ui_bucket_name)
          SEARCH_API=$(terraform output -raw policy_search_api_url)
          STATUS_API=$(terraform output -raw document_status_api_url)
          CF_URL=$(terraform output -raw cloudfront_url)
          
          # Expose them as action outputs
          echo "ui_bucket=$UI_BUCKET" >> $GITHUB_OUTPUT
          echo "search_api_url=$SEARCH_API" >> $GITHUB_OUTPUT
          echo "status_api_url=$STATUS_API" >> $GITHUB_OUTPUT
          echo "cloudfront_url=$CF_URL" >> $GITHUB_OUTPUT
          
          # Display for logging
          echo "✓ UI Bucket:    $UI_BUCKET"
          echo "✓ Search API:   $SEARCH_API"
          echo "✓ Status API:   $STATUS_API"
          echo "✓ CloudFront:   $CF_URL"
      
      - name: Process and Deploy UI Files
        working-directory: ./terraform/app
        run: |
          echo "Deploying UI to bucket: ${{ steps.tf.outputs.ui_bucket }}"
          
          mkdir -p ${GITHUB_WORKSPACE}/build/ui
          
          # Process index.html template
          ${GITHUB_WORKSPACE}/scripts/render_template.py \
            --template ${GITHUB_WORKSPACE}/ui/index.html \
            --output ${GITHUB_WORKSPACE}/build/ui/index.html \
            --search-api "${{ steps.tf.outputs.search_api_url }}" \
            --status-api "${{ steps.tf.outputs.status_api_url }}"
          
          # Upload index.html - using explicit step output
          aws s3 cp ${GITHUB_WORKSPACE}/build/ui/index.html \
            s3://${{ steps.tf.outputs.ui_bucket }}/index.html \
            --content-type "text/html"
          
          # Upload documentation.html
          aws s3 cp ${GITHUB_WORKSPACE}/ui/documentation.html \
            s3://${{ steps.tf.outputs.ui_bucket }}/documentation.html \
            --content-type "text/html"
          
          # Upload all image files
          aws s3 cp ${GITHUB_WORKSPACE}/ui/images/ \
            s3://${{ steps.tf.outputs.ui_bucket }}/images/ \
            --recursive
            
          echo "✅ UI deployed; available at: ${{ steps.tf.outputs.cloudfront_url }}"
          
          # Debug Bruno collection using the same approach
          if [ -f "$(terraform output -raw bruno_collection_path)" ]; then
            BRUNO_PATH=$(terraform output -raw bruno_collection_path)
            echo "Bruno collection URL inclusion check:"
            cat "$BRUNO_PATH" | grep -A 2 "API_URL" || echo "No API_URL found in Bruno collection"
          else
            echo "Bruno collection file not found - will be created during apply"
          fi
          
          # Verify Bruno README (only if it exists)
          if [ -f "${GITHUB_WORKSPACE}/build/bruno/README.md" ]; then
            echo "Bruno README API URL check:"
            cat "${GITHUB_WORKSPACE}/build/bruno/README.md" | grep -A 1 "API URL" || echo "No API URL found in README"
          else
            echo "Bruno README file not found - will be created during apply"
          fi